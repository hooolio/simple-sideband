when RULE_INIT priority 500 {
    # Version 1.0 4/7/2023 PRW 
    # Simple sideband iRule for doing simple sideband calls from iRules
    # Note that this must be created as /Common/simple_sideband ( or the references inside the irule updated )
    # Used for performing simple sideband operations eg to send a UDP payload of "test string":
    # set response [call /Common/simple_sideband::udp_req 10.20.20.34:53 "test string" {} ]
    # to perform a HTTP POST to the /login page:
    # set response [call /Common/simple_sideband::http_req 10.20.20.34:80 "/login" { method POST payload $payload }]
    #
    # 
    
}
proc request { {destination ""} {payload ""} {options {}} } {
    # Procedure for sending data
    # destination is either an IP address:port or a Virtual Server name
    # payload is a block of data - either ascii or binary
    # options contains extra options
        # debug - send debugging logs. Default is 0
        # connect_timeout - set connect timeout in secs ( default 1 sec )
        # timeout - set total timeout in seconds ( default 5 secs )
        # idle - set the idle timeout ( default 3 secs )
        # recv_bytes - set amount of data to receive
        # retries - set the number of retries ( default 1 )
    
    # Return data is an array where the first item is error and second is relevant data eg { 0 2416}
    # error is 0 for no error and 1 for an error
    # second entry is the error text in the case of an error, or relevant data in the case of no error
    # eg for a connect error, the return code would be { 1 "Connect to 1.2.3.4:23 failed status:timeout error: "}
    # for a successful connection with no received bytes this would be { 1 1234 } where 1234 is the number of sent bytes
    # for a successful connection with received bytes this would be { 1 {Hello world!} } where the second item is the data returned. Note that all of the data may not be retured because there may be a timeout first
     

    if { $destination == "" } {
        # Destination has not been set, throw an error
        return {1 "No destination set"}
    }
    if { $payload == "" } {
        # Destination has not been set, throw an error
        return {1 "No payload set"}
    }
    # Set defaults
    set protocol TCP
    set debug 0
    set connect_timeout 1
    set timeout 5
    set idle 3
    set recv_bytes 0
    set retries 1
    # Handle options
    foreach {option value} $options {
        switch -- $option {
            "protocol" { set protocol $value }
            "debug" { set debug 1 }
            "connect_timeout" { set connect_timeout [expr {$value * 1000}] }
            "timeout" { set timeout $value }
            "idle" { set idle $value }
            "recv_bytes" { set recv_bytes $value }
            "retries" { set retries $value }
        }
    }

    # Connect to endpoint
    set success 0
    set error ""
    for { set retry 0 } {$retry < $retries} {incr retry 1} {
        set start [clock seconds]
        # Try to connect
        if {[catch {\
        connect -protocol $protocol -timeout $timeout -idle $idle -status conn_status $destination } conn] || \
        ($conn eq "") \
        } {
            # Error in connection - try again
            set error "Connect to $destination failed status:$conn_status error: $conn"
            continue
        }
        if { $debug } { log local0.debug "Connected to $destination status: $conn_status" }
        # Send data
        if {[catch {\
        send -status send_status $conn $payload } sent] || \
        ($send_status ne "sent") || \
        ($sent != [string length $payload]) \
        } {
            # Error in sending - try again
            set error "Sending to $destination failed status: $send_status error: $sent"
            catch {close $conn}
            continue
        }
        if { $debug } { log local0.debug "Sent $payload to $destination status: $send_status" }
        
        if { ! $recv_bytes } {
            catch {close $conn}
            return [list 0 $sent]
        }
        # Check received data
        set received_data ""
        while { [expr {[clock seconds] - $start}] < $timeout } {
            append received_data [recv -timeout 500 $conn]
            if { $debug } { log local0.debug "Received $received_data" }
            if { [string length $received_data] >= $recv_bytes } {
                break
            }
        }
        catch {close $conn}
        return [list 0 $received_data]
    }
    return [list 1 $error]
}
proc http_req { {destination ""} {url "/"} {options {}} } {
    # Procedure for sending HTTP-based data
    # destination is either a virtual server or an IP address and port
    # url is the URL to be requested
    # options contains extra options
        # method - the method to use. Default is POST
        # version - the HTTP version to use eg 1.0
        # payload - in the case of a POST, this is the payload to be sent
        # headers - a TCL list of extra headers eg { Content-Type application/json }
    # Return is an array of status code ( or 0 for timeout ), response headers and payload
    # eg { 200 {Content-Length 12} {Hello world!} }
    # Set defaults
    set tcp_options { protocol TCP recv_bytes 12}
    set method GET
    set version 1.1
    set payload ""
    set headers_extra {}
    # Handle options
    foreach {option value} $options {
        switch -- $option {
            "method" { set method $value }
            "version" { set version $value }
            "payload" { set payload $value }
            "headers" { set headers_extra $value}
            default { lappend tcp_options [list $option $value]}
        }
    }
    # Create the basic request string
    set http_request "$method $url HTTP/$version\r\n"
    # Handle headers
    if { [string first : $destination] != -1 } {
        # If the destination is an IP address or name, use it as the Host
        set headers [list Host [lindex [split $destination :] 0] ]
    } else {
        set headers {}
    }
    
    if { $payload != "" } {
        # Set Content-Length
        lappend headers [list Content-Length [string length $payload]]
    }
    foreach {header value} $headers_extra {
        set i [lsearch -exact $headers $header ]
        if { $i != -1 } {
            # If the header exists, update it
            set headers [lreplace $headers $i [expr {$i + 1}] $header $value]
        } else {
            # Else append it
            lappend headers [list $header $value]
        }
    }
    foreach {header value} $headers {
        append http_request "$header: $value\r\n"
    }
    append http_request "\r\n$payload"
    set response [call /Common/simple_sideband::request $destination $http_request $tcp_options]
    if { [lindex $response 0] == 1 } {
        # There was an error, return error
        return [list 0 {} {}]
    } else {
        # An HTTP response which we need to decode
        set data [lindex $response 1]
        # First, split it into headers and body based on \r\n\r\n
        set split [string first "\r\n\r\n" $data ]
        if { $split == -1 } {
            # Cannot parse the response
            return [list 0 {} {}]
        }
        set head_string [string map [list "\r\n" "\n"] [string range $data 0 $split]] 
        set head_list [split $head_string "\n"]
        # Retrieve the header line eg HTTP/1.1 200 OK
        set header_line [lindex $head_list 0]
        set status_code [lindex [split $header_line " "] 1]
        # Handle returned headers
        set headers {}
        foreach item [lrange $head_list 1 end] {
            if { $item == "" } { continue }
            set k [split $item :]
            lappend headers [lindex $k 0] [string trim [lindex $k 1]]
        }
        # Increment by 4 to skip the \r\n\r\n
        incr split 4
        set body [string range $data $split end]
        return [ list $status_code $headers $body]
    }
}
proc tcp_req { {destination ""} {payload ""} {options {}} } {
    # Procedure for sending TCP-based data
    lappend options protocol TCP
    return [call /Common/simple_sideband::request $destination $payload $options]
}
proc udp_req { {destination ""} {payload ""} {options {}} } {
    # Procedure for sending UDP-based data
    lappend options protocol UDP
    return [call /Common/simple_sideband::request $destination $payload $options]
}